import{_ as n,o as e,c as l,a as s,b as t,t as o,f as p}from"./app.2db74fad.js";const f=JSON.parse('{"title":"Flatten a Dictionary","description":"","frontmatter":{"date":"2023-01-22T00:00:00.000Z","title":"Flatten a Dictionary","tags":["algorithm","pramp","recursion"]},"headers":[{"level":2,"title":"Question","slug":"question","link":"#question","children":[{"level":3,"title":"Example","slug":"example","link":"#example","children":[]}]},{"level":2,"title":"Solution","slug":"solution","link":"#solution","children":[{"level":3,"title":"Code","slug":"code","link":"#code","children":[]},{"level":3,"title":"Time& Space Complexity","slug":"time-space-complexity","link":"#time-space-complexity","children":[]}]}],"relativePath":"posts/flattern_dict.md"}'),c={name:"posts/flattern_dict.md"},i={id:"frontmatter-title",tabindex:"-1"},r=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),y=p(`<h2 id="question" tabindex="-1">Question <a class="header-anchor" href="#question" aria-hidden="true">#</a></h2><p>Given a dictionary dict, write a function flattenDictionary that returns a flattened version of it. If a certain key is empty, it should be excluded from the output (see e in the example below).</p><h3 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-hidden="true">#</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">input:  dict = {</span></span>
<span class="line"><span style="color:#A6ACCD;">            &quot;Key1&quot; : &quot;1&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">            &quot;Key2&quot; : {</span></span>
<span class="line"><span style="color:#A6ACCD;">                &quot;a&quot; : &quot;2&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">                &quot;b&quot; : &quot;3&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">                &quot;c&quot; : {</span></span>
<span class="line"><span style="color:#A6ACCD;">                    &quot;d&quot; : &quot;3&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">                    &quot;e&quot; : {</span></span>
<span class="line"><span style="color:#A6ACCD;">                        &quot;&quot; : &quot;1&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">                    }</span></span>
<span class="line"><span style="color:#A6ACCD;">                }</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;">output: {</span></span>
<span class="line"><span style="color:#A6ACCD;">            &quot;Key1&quot; : &quot;1&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">            &quot;Key2.a&quot; : &quot;2&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">            &quot;Key2.b&quot; : &quot;3&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">            &quot;Key2.c.d&quot; : &quot;3&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">            &quot;Key2.c.e&quot; : &quot;1&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">        }</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="solution" tabindex="-1">Solution <a class="header-anchor" href="#solution" aria-hidden="true">#</a></h2><p>Recursion is a natural choice for this kind of problem.</p><p>We iterate over the keys in the dictionary and distinguish between two cases:</p><ol><li>If the value mapped to a key is primitive, we take that key and simply concatenate it to the flattened key we&#39;ve created up to this point. We then map the resulting key to the value in the output dictionary.</li><li>If the value is a dictionary, we again concatenate the keys, but instead of adding the resulting key and value to the output dictionary, we recurse on the value with the newly formed key.</li></ol><p>Because it is useful to create the output dictionary outside of the recursive function, it makes sense to use a helper function in this problem.</p><h3 id="code" tabindex="-1">Code <a class="header-anchor" href="#code" aria-hidden="true">#</a></h3><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">def</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">flatten_dict</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">path</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">original_dict</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;">flat_dict</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">for</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> value </span><span style="color:#89DDFF;">in</span><span style="color:#A6ACCD;"> original_dict</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">items</span><span style="color:#89DDFF;">():</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> path </span><span style="color:#89DDFF;">and</span><span style="color:#A6ACCD;"> key</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            updated_path </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">f</span><span style="color:#C3E88D;">&#39;</span><span style="color:#F78C6C;">{</span><span style="color:#A6ACCD;">path</span><span style="color:#F78C6C;">}</span><span style="color:#C3E88D;">.</span><span style="color:#F78C6C;">{</span><span style="color:#A6ACCD;">key</span><span style="color:#F78C6C;">}</span><span style="color:#C3E88D;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">elif</span><span style="color:#A6ACCD;"> path</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            updated_path </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> path</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">else</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            updated_path </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> key</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">not</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">isinstance</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">value</span><span style="color:#89DDFF;">,</span><span style="color:#82AAFF;"> </span><span style="color:#FFCB6B;">dict</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">            flat_dict</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">updated_path</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> value</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">else</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#82AAFF;">flatten_dict</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">updated_path</span><span style="color:#89DDFF;">,</span><span style="color:#82AAFF;"> value</span><span style="color:#89DDFF;">,</span><span style="color:#82AAFF;"> flat_dict</span><span style="color:#89DDFF;">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">def</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">solution</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">original_dict</span><span style="color:#89DDFF;">):</span></span>
<span class="line"><span style="color:#A6ACCD;">    flat_dict </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">flatten_dict</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#82AAFF;"> original_dict</span><span style="color:#89DDFF;">,</span><span style="color:#82AAFF;"> flat_dict</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">print</span><span style="color:#89DDFF;">(</span><span style="color:#82AAFF;">flat_dict</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">return</span><span style="color:#A6ACCD;"> flat_dict</span></span>
<span class="line"></span>
<span class="line"></span></code></pre></div><h3 id="time-space-complexity" tabindex="-1">Time&amp; Space Complexity <a class="header-anchor" href="#time-space-complexity" aria-hidden="true">#</a></h3><p>Time Complexity: O(N)</p><p>where N is the number of keys in the input dictionary.</p><p>We visit every key in the dictionary only once, hence the linear time complexity.</p><p>Space Complexity: O(N)</p><p>since the output dictionary is asymptotically as big as the input dictionary.</p><p>We also store recursive calls in the execution stack which in the worst-case scenario could be O(N), as well.</p><p>The total is still O(N).</p>`,19);function A(a,D,C,u,d,F){return e(),l("div",null,[s("h1",i,[t(o(a.$frontmatter.title)+" ",1),r]),y])}const q=n(c,[["render",A]]);export{f as __pageData,q as default};
